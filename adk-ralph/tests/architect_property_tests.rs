//! Property-based tests for Architect Agent output.
//!
//! These tests validate the correctness properties for design documents
//! and task lists generated by the Architect Agent.

use adk_ralph::{
    Component, DesignDocument, FileStructure, Phase, Sprint, Task, TaskList, TaskStatus,
    TechnologyStack,
};
use proptest::prelude::*;

// ============================================================================
// Generators for Design Document types
// ============================================================================

/// Generate a valid component name (non-empty alphanumeric with underscores)
fn arb_component_name() -> impl Strategy<Value = String> {
    "[A-Z][a-zA-Z0-9_]{2,20}".prop_map(|s| s)
}

/// Generate a valid purpose description
fn arb_purpose() -> impl Strategy<Value = String> {
    "[A-Za-z ]{10,50}".prop_map(|s| s.trim().to_string())
}

/// Generate a valid interface method signature
fn arb_interface() -> impl Strategy<Value = String> {
    prop_oneof![
        Just("fn process() -> Result<()>".to_string()),
        Just("fn execute(&self, input: &str) -> Output".to_string()),
        Just("async fn run(&mut self) -> Result<Value>".to_string()),
        Just("fn new(config: Config) -> Self".to_string()),
    ]
}

/// Generate a valid Component
fn arb_component() -> impl Strategy<Value = Component> {
    (
        arb_component_name(),
        arb_purpose(),
        prop::collection::vec(arb_interface(), 0..3),
        prop::collection::vec(arb_component_name(), 0..2),
    )
        .prop_map(|(name, purpose, interfaces, deps)| {
            let mut component = Component::new(name, purpose);
            for iface in interfaces {
                component.add_interface(iface);
            }
            for dep in deps {
                component.add_dependency(dep);
            }
            component
        })
}

/// Generate a valid programming language
fn arb_language() -> impl Strategy<Value = String> {
    prop_oneof![
        Just("rust".to_string()),
        Just("python".to_string()),
        Just("typescript".to_string()),
        Just("go".to_string()),
        Just("java".to_string()),
    ]
}

/// Generate a valid testing framework for a language
fn arb_testing_framework(language: &str) -> String {
    match language {
        "rust" => "cargo test".to_string(),
        "python" => "pytest".to_string(),
        "typescript" => "vitest".to_string(),
        "go" => "go test".to_string(),
        "java" => "junit".to_string(),
        _ => "test".to_string(),
    }
}

/// Generate a valid build tool for a language
fn arb_build_tool(language: &str) -> String {
    match language {
        "rust" => "cargo".to_string(),
        "python" => "pip".to_string(),
        "typescript" => "npm".to_string(),
        "go" => "go build".to_string(),
        "java" => "maven".to_string(),
        _ => "make".to_string(),
    }
}

/// Generate a valid TechnologyStack
fn arb_technology_stack() -> impl Strategy<Value = TechnologyStack> {
    arb_language().prop_map(|lang| {
        let testing = arb_testing_framework(&lang);
        let build = arb_build_tool(&lang);
        TechnologyStack::new(&lang)
            .with_testing(testing)
            .with_build_tool(build)
    })
}

/// Generate a valid file name
fn arb_file_name() -> impl Strategy<Value = String> {
    prop_oneof![
        Just("main.rs".to_string()),
        Just("lib.rs".to_string()),
        Just("mod.rs".to_string()),
        Just("config.rs".to_string()),
        Just("error.rs".to_string()),
        Just("utils.py".to_string()),
        Just("index.ts".to_string()),
        Just("Cargo.toml".to_string()),
        Just("package.json".to_string()),
    ]
}

/// Generate a valid directory name
fn arb_dir_name() -> impl Strategy<Value = String> {
    prop_oneof![
        Just("src".to_string()),
        Just("tests".to_string()),
        Just("lib".to_string()),
        Just("models".to_string()),
        Just("tools".to_string()),
        Just("agents".to_string()),
    ]
}

/// Generate a valid FileStructure (non-recursive for simplicity)
fn arb_file_structure() -> impl Strategy<Value = FileStructure> {
    (arb_dir_name(), prop::collection::vec(arb_file_name(), 1..5)).prop_map(|(dir_name, files)| {
        let mut root = FileStructure::directory(&dir_name, "Project root");
        let mut src = FileStructure::directory("src", "Source files");
        for file in files {
            src.add_child(FileStructure::file(&file, "Source file"));
        }
        root.add_child(src);
        root.add_child(FileStructure::file("README.md", "Documentation"));
        root
    })
}

/// Generate a valid Mermaid diagram
fn arb_mermaid_diagram() -> impl Strategy<Value = String> {
    prop_oneof![
        Just("flowchart TB\n  A[Start] --> B[Process]\n  B --> C[End]".to_string()),
        Just("flowchart LR\n  Input --> Processing --> Output".to_string()),
        Just("graph TD\n  A --> B\n  B --> C\n  C --> D".to_string()),
    ]
}

/// Generate a valid project name
fn arb_project_name() -> impl Strategy<Value = String> {
    "[a-z][a-z0-9_-]{3,15}".prop_map(|s| s)
}

/// Generate a valid overview text
fn arb_overview() -> impl Strategy<Value = String> {
    "[A-Za-z .,]{20,100}".prop_map(|s| s.trim().to_string())
}

/// Generate a complete DesignDocument
fn arb_complete_design_document() -> impl Strategy<Value = DesignDocument> {
    (
        arb_project_name(),
        arb_overview(),
        arb_mermaid_diagram(),
        prop::collection::vec(arb_component(), 1..4),
        arb_file_structure(),
        arb_technology_stack(),
    )
        .prop_map(
            |(project, overview, diagram, components, file_structure, tech_stack)| {
                let mut design = DesignDocument::new(project, overview);
                design.set_diagram(diagram);
                for component in components {
                    design.add_component(component);
                }
                design.set_file_structure(file_structure);
                design.set_technology_stack(tech_stack);
                design
            },
        )
}

// ============================================================================
// Generators for Task types
// ============================================================================

/// Generate a valid task ID
fn arb_task_id() -> impl Strategy<Value = String> {
    (1u32..1000).prop_map(|n| format!("TASK-{:03}", n))
}

/// Generate a valid task title
fn arb_task_title() -> impl Strategy<Value = String> {
    prop_oneof![
        Just("Implement core module".to_string()),
        Just("Add error handling".to_string()),
        Just("Create data models".to_string()),
        Just("Write unit tests".to_string()),
        Just("Set up project structure".to_string()),
        Just("Implement API endpoints".to_string()),
        Just("Add configuration support".to_string()),
    ]
}

/// Generate a valid task description
fn arb_task_description() -> impl Strategy<Value = String> {
    "[A-Za-z .,]{15,80}".prop_map(|s| s.trim().to_string())
}

/// Generate a valid priority (1-5)
fn arb_priority() -> impl Strategy<Value = u32> {
    1u32..=5
}

/// Generate a valid TaskStatus
fn arb_task_status() -> impl Strategy<Value = TaskStatus> {
    prop_oneof![
        Just(TaskStatus::Pending),
        Just(TaskStatus::InProgress),
        Just(TaskStatus::Completed),
        Just(TaskStatus::Blocked),
    ]
}

/// Generate a valid user story ID
fn arb_user_story_id() -> impl Strategy<Value = String> {
    (1u32..100).prop_map(|n| format!("US-{:03}", n))
}

/// Generate a valid Task with all required fields
fn arb_task() -> impl Strategy<Value = Task> {
    (
        arb_task_id(),
        arb_task_title(),
        arb_task_description(),
        arb_priority(),
        arb_task_status(),
        arb_user_story_id(),
    )
        .prop_map(|(id, title, description, priority, status, user_story_id)| {
            let mut task = Task::new(&id, &title, &description, priority);
            task.status = status;
            task.user_story_id = Some(user_story_id);
            task
        })
}

/// Generate a valid Sprint
fn arb_sprint() -> impl Strategy<Value = Sprint> {
    (
        (1u32..10).prop_map(|n| format!("sprint-{}", n)),
        "[A-Za-z ]{5,20}".prop_map(|s| s.trim().to_string()),
        prop::collection::vec(arb_task(), 1..5),
    )
        .prop_map(|(id, name, tasks)| {
            let mut sprint = Sprint::new(&id, &name);
            for task in tasks {
                sprint.add_task(task);
            }
            sprint
        })
}

/// Generate a valid Phase
fn arb_phase() -> impl Strategy<Value = Phase> {
    (
        (1u32..5).prop_map(|n| format!("phase-{}", n)),
        "[A-Za-z ]{5,25}".prop_map(|s| s.trim().to_string()),
        prop::collection::vec(arb_sprint(), 1..3),
    )
        .prop_map(|(id, name, sprints)| {
            let mut phase = Phase::new(&id, &name);
            for sprint in sprints {
                phase.add_sprint(sprint);
            }
            phase
        })
}

/// Generate a valid TaskList with phases
fn arb_task_list_with_phases() -> impl Strategy<Value = TaskList> {
    (
        arb_project_name(),
        arb_language(),
        prop::collection::vec(arb_phase(), 1..3),
    )
        .prop_map(|(project, language, phases)| {
            let mut task_list = TaskList::new(&project, &language);
            for phase in phases {
                task_list.add_phase(phase);
            }
            task_list
        })
}

/// Generate a valid TaskList with flat tasks (ensuring unique IDs)
fn arb_task_list_flat() -> impl Strategy<Value = TaskList> {
    (
        arb_project_name(),
        arb_language(),
        1usize..10,
    )
        .prop_flat_map(|(project, language, count)| {
            // Generate unique task IDs by using sequential numbers
            let tasks_strategy = (0..count)
                .map(|i| {
                    (
                        arb_task_title(),
                        arb_task_description(),
                        arb_priority(),
                        arb_task_status(),
                        arb_user_story_id(),
                    )
                        .prop_map(move |(title, description, priority, status, user_story_id)| {
                            let id = format!("TASK-{:03}", i + 1);
                            let mut task = Task::new(&id, &title, &description, priority);
                            task.status = status;
                            task.user_story_id = Some(user_story_id);
                            task
                        })
                })
                .collect::<Vec<_>>();
            
            (Just(project), Just(language), tasks_strategy)
        })
        .prop_map(|(project, language, tasks)| {
            let mut task_list = TaskList::new(&project, &language);
            for task in tasks {
                task_list.add_task(task);
            }
            task_list
        })
}

// ============================================================================
// Property Tests
// ============================================================================

proptest! {
    #![proptest_config(ProptestConfig::with_cases(100))]

    // ========================================================================
    // Property 2: Design Completeness
    // ========================================================================

    /// **Feature: ralph-wiggum-pattern, Property 2: Design Completeness**
    /// *For any* valid PRD, the generated design file SHALL contain:
    /// architecture overview, component diagram, file structure, and technology stack.
    /// **Validates: Requirements 2.3, 2.4, 2.5, 2.6**
    #[test]
    fn prop_design_completeness(design in arb_complete_design_document()) {
        // Property: A complete design document must have all required sections
        
        // 2.3: Component diagram (Mermaid format)
        prop_assert!(
            design.component_diagram.is_some(),
            "Design must have a component diagram"
        );
        let diagram = design.component_diagram.as_ref().unwrap();
        prop_assert!(
            !diagram.is_empty(),
            "Component diagram must not be empty"
        );
        
        // 2.4: Interfaces between components (components with interfaces)
        prop_assert!(
            !design.components.is_empty(),
            "Design must have at least one component"
        );
        
        // 2.5: File/folder organization structure
        prop_assert!(
            design.file_structure.is_some(),
            "Design must have a file structure"
        );
        let file_structure = design.file_structure.as_ref().unwrap();
        prop_assert!(
            !file_structure.name.is_empty(),
            "File structure must have a root name"
        );
        
        // 2.6: Technology choices and dependencies
        prop_assert!(
            design.technology_stack.is_some(),
            "Design must have a technology stack"
        );
        let tech_stack = design.technology_stack.as_ref().unwrap();
        prop_assert!(
            !tech_stack.language.is_empty(),
            "Technology stack must specify a language"
        );
        
        // Additional: Overview must be present (2.2)
        prop_assert!(
            !design.overview.is_empty(),
            "Design must have an architecture overview"
        );
        
        // The is_complete() method should return true for complete designs
        prop_assert!(
            design.is_complete(),
            "Design with all sections should report as complete"
        );
    }

    /// **Feature: ralph-wiggum-pattern, Property 2a: Design Validation**
    /// *For any* design document, validation should pass if and only if
    /// project name and overview are non-empty.
    /// **Validates: Requirements 2.2**
    #[test]
    fn prop_design_validation(
        project in arb_project_name(),
        overview in arb_overview()
    ) {
        let design = DesignDocument::new(&project, &overview);
        
        // Validation should pass for non-empty project and overview
        let result = design.validate();
        prop_assert!(
            result.is_ok(),
            "Design with valid project '{}' and overview should validate: {:?}",
            project, result
        );
    }

    /// **Feature: ralph-wiggum-pattern, Property 2b: Design Incompleteness Detection**
    /// *For any* design document missing required sections, is_complete() should return false.
    /// **Validates: Requirements 2.3, 2.4, 2.5, 2.6**
    #[test]
    fn prop_design_incompleteness_detection(
        project in arb_project_name(),
        overview in arb_overview()
    ) {
        // A design with only project and overview should be incomplete
        let design = DesignDocument::new(&project, &overview);
        
        prop_assert!(
            !design.is_complete(),
            "Design without diagram, components, file structure, or tech stack should be incomplete"
        );
    }

    // ========================================================================
    // Property 3: Task Structure Validity
    // ========================================================================

    /// **Feature: ralph-wiggum-pattern, Property 3: Task Structure Validity**
    /// *For any* generated tasks.json, each task SHALL have: id, title, description,
    /// priority, status (one of pending/in_progress/completed/blocked), dependencies array,
    /// and user_story_id.
    /// **Validates: Requirements 3.2, 3.5, 3.6**
    #[test]
    fn prop_task_structure_validity(task in arb_task()) {
        // 3.2: Task must have id, title, description, priority, status, dependencies
        
        // ID must be non-empty and follow pattern
        prop_assert!(
            !task.id.is_empty(),
            "Task must have a non-empty ID"
        );
        prop_assert!(
            task.id.starts_with("TASK-"),
            "Task ID should follow TASK-XXX pattern, got: {}",
            task.id
        );
        
        // Title must be non-empty
        prop_assert!(
            !task.title.is_empty(),
            "Task must have a non-empty title"
        );
        
        // Description must be non-empty
        prop_assert!(
            !task.description.is_empty(),
            "Task must have a non-empty description"
        );
        
        // Priority must be in valid range (1-5)
        prop_assert!(
            task.priority >= 1 && task.priority <= 5,
            "Task priority must be between 1 and 5, got: {}",
            task.priority
        );
        
        // 3.5: Status must be one of the valid values
        prop_assert!(
            matches!(
                task.status,
                TaskStatus::Pending
                    | TaskStatus::InProgress
                    | TaskStatus::Completed
                    | TaskStatus::Blocked
                    | TaskStatus::Skipped
            ),
            "Task status must be a valid TaskStatus variant"
        );
        
        // 3.6: Task should reference user story
        prop_assert!(
            task.user_story_id.is_some(),
            "Task should have a user_story_id reference"
        );
        let user_story_id = task.user_story_id.as_ref().unwrap();
        prop_assert!(
            user_story_id.starts_with("US-"),
            "User story ID should follow US-XXX pattern, got: {}",
            user_story_id
        );
        
        // Dependencies array exists (even if empty)
        // This is implicitly true since dependencies is a Vec, but we verify it's accessible
        let _ = &task.dependencies;
    }

    /// **Feature: ralph-wiggum-pattern, Property 3a: TaskList Validation**
    /// *For any* valid task list, validation should pass with no duplicate IDs
    /// and all dependencies referencing existing tasks.
    /// **Validates: Requirements 3.2**
    #[test]
    fn prop_task_list_validation(task_list in arb_task_list_flat()) {
        // Task list should validate successfully
        let result = task_list.validate();
        prop_assert!(
            result.is_ok(),
            "Valid task list should pass validation: {:?}",
            result
        );
        
        // Project and language must be set
        prop_assert!(
            !task_list.project.is_empty(),
            "Task list must have a project name"
        );
        prop_assert!(
            !task_list.language.is_empty(),
            "Task list must have a language"
        );
    }

    /// **Feature: ralph-wiggum-pattern, Property 3b: Task List with Phases**
    /// *For any* task list with phases, all tasks should be accessible via get_all_tasks().
    /// **Validates: Requirements 3.3, 3.4**
    #[test]
    fn prop_task_list_phases_accessibility(task_list in arb_task_list_with_phases()) {
        // Count tasks in phases
        let mut expected_count = 0;
        for phase in &task_list.phases {
            for sprint in &phase.sprints {
                expected_count += sprint.tasks.len();
            }
        }
        
        // get_all_tasks should return all tasks
        let all_tasks = task_list.get_all_tasks();
        prop_assert_eq!(
            all_tasks.len(),
            expected_count,
            "get_all_tasks() should return all tasks from all phases and sprints"
        );
    }

    /// **Feature: ralph-wiggum-pattern, Property 3c: Task Status Transitions**
    /// *For any* task, status transitions should be valid and trackable.
    /// **Validates: Requirements 3.5**
    #[test]
    fn prop_task_status_transitions(
        id in arb_task_id(),
        title in arb_task_title(),
        description in arb_task_description(),
        priority in arb_priority()
    ) {
        let mut task = Task::new(&id, &title, &description, priority);
        
        // Initial state should be pending
        prop_assert_eq!(
            task.status,
            TaskStatus::Pending,
            "New task should start as Pending"
        );
        prop_assert!(task.is_pending());
        
        // Start should transition to InProgress
        task.start();
        prop_assert_eq!(
            task.status,
            TaskStatus::InProgress,
            "After start(), task should be InProgress"
        );
        prop_assert_eq!(task.attempts, 1, "Attempts should increment on start");
        
        // Complete should transition to Completed
        task.complete(Some("abc123".to_string()));
        prop_assert_eq!(
            task.status,
            TaskStatus::Completed,
            "After complete(), task should be Completed"
        );
        prop_assert!(task.is_completed());
        prop_assert_eq!(
            task.commit_hash,
            Some("abc123".to_string()),
            "Commit hash should be set on completion"
        );
    }

    /// **Feature: ralph-wiggum-pattern, Property 3d: Task Stats Consistency**
    /// *For any* task list, stats should accurately reflect task statuses.
    /// **Validates: Requirements 3.5**
    #[test]
    fn prop_task_stats_consistency(task_list in arb_task_list_flat()) {
        let stats = task_list.get_stats();
        let all_tasks = task_list.get_all_tasks();
        
        // Total should match actual task count
        prop_assert_eq!(
            stats.total,
            all_tasks.len(),
            "Stats total should match actual task count"
        );
        
        // Sum of status counts should equal total
        let sum = stats.completed + stats.in_progress + stats.pending + stats.blocked;
        // Note: skipped tasks are not counted in these stats, so we need to account for them
        let skipped_count = all_tasks.iter().filter(|t| t.status == TaskStatus::Skipped).count();
        prop_assert_eq!(
            sum + skipped_count,
            stats.total,
            "Sum of status counts should equal total"
        );
        
        // Completion rate should be accurate
        if stats.total > 0 {
            let expected_rate = (stats.completed as f64 / stats.total as f64) * 100.0;
            prop_assert!(
                (stats.completion_rate - expected_rate).abs() < 0.01,
                "Completion rate should be accurate"
            );
        }
    }
}

// ============================================================================
// Additional Unit Tests for Edge Cases
// ============================================================================

#[cfg(test)]
mod edge_case_tests {
    use super::*;

    #[test]
    fn test_empty_design_is_incomplete() {
        let design = DesignDocument::new("test", "overview");
        assert!(!design.is_complete());
    }

    #[test]
    fn test_design_with_empty_project_fails_validation() {
        let design = DesignDocument::new("", "overview");
        assert!(design.validate().is_err());
    }

    #[test]
    fn test_design_with_empty_overview_fails_validation() {
        let design = DesignDocument::new("project", "");
        assert!(design.validate().is_err());
    }

    #[test]
    fn test_task_list_with_duplicate_ids_fails_validation() {
        let mut task_list = TaskList::new("test", "rust");
        task_list.add_task(Task::new("TASK-001", "First", "Desc", 1));
        task_list.add_task(Task::new("TASK-001", "Duplicate", "Desc", 2));
        
        assert!(task_list.validate().is_err());
    }

    #[test]
    fn test_task_list_with_invalid_dependency_fails_validation() {
        let mut task_list = TaskList::new("test", "rust");
        let mut task = Task::new("TASK-001", "First", "Desc", 1);
        task.add_dependency("TASK-999"); // Non-existent dependency
        task_list.add_task(task);
        
        assert!(task_list.validate().is_err());
    }

    #[test]
    fn test_task_blocking_sets_status_and_notes() {
        let mut task = Task::new("TASK-001", "Test", "Desc", 1);
        task.block("Missing dependency");
        
        assert!(task.is_blocked());
        assert!(task.notes.contains("Blocked"));
        assert!(task.notes.contains("Missing dependency"));
    }
}
