<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ADK 3D UI</title>
    <style>
      :root {
        --bg: #070a16;
        --bg2: #0d1530;
        --panel: rgba(10, 16, 34, 0.86);
        --line: rgba(255, 255, 255, 0.16);
        --text: #edf2ff;
        --muted: #93a3c8;
        --good: #60e6bf;
        --warn: #f2c563;
        --bad: #ff6b90;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        color: var(--text);
        background:
          radial-gradient(circle at 15% 5%, #24396f 0%, transparent 35%),
          radial-gradient(circle at 85% 8%, #5f2d78 0%, transparent 30%),
          linear-gradient(145deg, var(--bg2) 0%, var(--bg) 65%);
        font-family: "SF Mono", Menlo, Consolas, Monaco, monospace;
        min-height: 100vh;
      }
      .shell {
        max-width: 1320px;
        margin: 0 auto;
        padding: 16px;
        display: grid;
        gap: 12px;
      }
      .hero {
        background: linear-gradient(135deg, rgba(102, 230, 198, 0.18), rgba(88, 136, 253, 0.16));
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 14px;
      }
      .hero h1 {
        margin: 0;
        font-size: 34px;
        letter-spacing: 0.05em;
      }
      .hero p {
        margin: 8px 0 0;
        color: var(--muted);
      }
      .status {
        color: var(--warn);
        font-size: 16px;
      }
      .grid {
        display: grid;
        grid-template-columns: 350px minmax(540px, 1fr) 360px;
        gap: 12px;
      }
      .card {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: var(--panel);
        padding: 12px;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.08em;
      }
      textarea,
      input,
      button {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.22);
        background: rgba(9, 14, 31, 0.86);
        color: var(--text);
        padding: 10px;
        font: inherit;
      }
      textarea {
        resize: vertical;
        min-height: 88px;
      }
      button {
        cursor: pointer;
        background: linear-gradient(90deg, #3dd5ad 0%, #5689f9 100%);
        color: #031018;
        font-weight: 700;
        border: none;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      #reject {
        background: linear-gradient(90deg, #ff7f9d 0%, #f05066 100%);
      }
      .stack > * + * {
        margin-top: 10px;
      }
      .viewport-wrap {
        padding: 0;
        overflow: hidden;
      }
      #viewport {
        width: 100%;
        height: 620px;
        display: block;
        border-radius: 12px;
        overflow: hidden;
        background: radial-gradient(circle at center, #182a54 0%, #090d1f 60%);
      }
      .hint {
        margin: 8px 12px 12px;
        color: var(--muted);
        font-size: 12px;
      }
      .log {
        height: 620px;
        overflow: auto;
        white-space: pre-wrap;
        background: rgba(4, 8, 18, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 10px;
        font-size: 12px;
        line-height: 1.45;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 4px 9px;
        font-size: 11px;
        color: var(--muted);
      }
      .pills {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      @media (max-width: 1200px) {
        .grid {
          grid-template-columns: 1fr;
        }
        #viewport,
        .log {
          height: 520px;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <section class="hero">
        <h1>ADK 3D UI <span id="status" class="status">idle</span></h1>
        <p>Natural-language prompts stream typed 3D scene operations. Click orbs to emit `select` events.</p>
      </section>

      <div class="grid">
        <section class="card stack">
          <label for="prompt">Prompt</label>
          <textarea id="prompt">Show me platform health and what needs attention right now.</textarea>
          <button id="run">Run Prompt</button>
          <button id="command">Send Command Event</button>
          <button id="approve" disabled>Approve Pending Action</button>
          <button id="reject" disabled>Reject Pending Action</button>
          <input id="session" readonly />
          <div class="pills">
            <span class="pill" id="opsCount">ops: 0</span>
            <span class="pill" id="objectsCount">objects: 0</span>
            <span class="pill" id="fps">fps: --</span>
            <span class="pill" id="pendingAction">pending_action: none</span>
          </div>
        </section>

        <section class="card viewport-wrap">
          <div id="viewport"></div>
          <div class="hint">Phase 1 runtime: incremental `create/patch/remove` without full rerender.</div>
        </section>

        <section class="card">
          <div class="log" id="log"></div>
        </section>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.169.0/build/three.module.js";

      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");
      const sessionEl = document.getElementById("session");
      const promptEl = document.getElementById("prompt");
      const runBtn = document.getElementById("run");
      const commandBtn = document.getElementById("command");
      const approveBtn = document.getElementById("approve");
      const rejectBtn = document.getElementById("reject");
      const opsCountEl = document.getElementById("opsCount");
      const objectsCountEl = document.getElementById("objectsCount");
      const fpsEl = document.getElementById("fps");
      const pendingActionEl = document.getElementById("pendingAction");
      const viewport = document.getElementById("viewport");

      let sessionId = null;
      let eventSource = null;
      let clientSeq = 0;
      let opsApplied = 0;
      let pendingActionId = null;
      let pendingActionRisk = null;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(58, 1, 0.1, 200);
      camera.position.set(0, 1.0, 6.8);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      viewport.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xcad8ff, 0x080a11, 1.0);
      scene.add(hemi);
      const key = new THREE.DirectionalLight(0xffffff, 1.0);
      key.position.set(2, 3, 4);
      scene.add(key);

      const starField = new THREE.Points(
        new THREE.BufferGeometry(),
        new THREE.PointsMaterial({ color: 0xffffff, size: 0.018, transparent: true, opacity: 0.65 })
      );
      {
        const points = [];
        for (let i = 0; i < 2200; i += 1) {
          const x = (Math.random() - 0.5) * 48;
          const y = (Math.random() - 0.5) * 28;
          const z = -Math.random() * 55;
          points.push(x, y, z);
        }
        starField.geometry.setAttribute("position", new THREE.Float32BufferAttribute(points, 3));
      }
      scene.add(starField);

      const registry = new Map();
      const root = new THREE.Group();
      root.name = "world-root";
      scene.add(root);

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const animated = new Map();

      function log(line, data) {
        const timestamp = new Date().toISOString();
        const payload = data ? `\n${JSON.stringify(data, null, 2)}` : "";
        logEl.textContent = `[${timestamp}] ${line}${payload}\n\n` + logEl.textContent;
      }

      function setPendingAction(actionId, risk) {
        pendingActionId = actionId || null;
        pendingActionRisk = risk || null;
        const enabled = Boolean(pendingActionId);
        approveBtn.disabled = !enabled;
        rejectBtn.disabled = !enabled;
        if (!enabled) {
          pendingActionEl.textContent = "pending_action: none";
          return;
        }
        pendingActionEl.textContent = `pending_action: ${pendingActionId} (${pendingActionRisk || "unknown"})`;
      }

      function colorForStatus(status) {
        const s = String(status || "").toLowerCase();
        if (s === "healthy") return 0x58dbb3;
        if (s === "warning" || s === "degraded") return 0xf2c563;
        if (s === "error" || s === "critical") return 0xff6f95;
        return 0x7ab5ff;
      }

      function createTextTexture(text, opts = {}) {
        const canvas = document.createElement("canvas");
        const width = opts.width || 1024;
        const height = opts.height || 256;
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, width, height);
        if (opts.bg) {
          ctx.fillStyle = opts.bg;
          ctx.fillRect(0, 0, width, height);
        }
        ctx.fillStyle = opts.color || "#f5f8ff";
        ctx.font = `${opts.weight || 700} ${opts.fontSize || 76}px ${opts.fontFamily || "Arial"}`;
        ctx.textAlign = opts.align || "center";
        ctx.textBaseline = "middle";
        const x = opts.align === "left" ? 24 : width * 0.5;
        ctx.fillText(String(text || ""), x, height * 0.5);
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.needsUpdate = true;
        return texture;
      }

      function createTextSprite(text, opts = {}) {
        const texture = createTextTexture(text, opts);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
        const sprite = new THREE.Sprite(material);
        const scaleX = opts.scaleX || 3.2;
        const scaleY = opts.scaleY || 0.85;
        sprite.scale.set(scaleX, scaleY, 1);
        return sprite;
      }

      function setTransform(object3d, props = {}) {
        if (typeof props.x === "number" || typeof props.y === "number" || typeof props.z === "number") {
          object3d.position.set(props.x || 0, props.y || 0, props.z || 0);
        }
        if (typeof props.rx === "number" || typeof props.ry === "number" || typeof props.rz === "number") {
          object3d.rotation.set(props.rx || 0, props.ry || 0, props.rz || 0);
        }
        if (typeof props.sx === "number" || typeof props.sy === "number" || typeof props.sz === "number") {
          object3d.scale.set(props.sx || 1, props.sy || 1, props.sz || 1);
        }
      }

      function ensureLabel(group, id, text, yOffset) {
        let label = group.getObjectByName(id);
        if (!label) {
          label = createTextSprite(text, { fontSize: 56, scaleX: 2.2, scaleY: 0.52, color: "#e6ebff" });
          label.name = id;
          label.position.set(0, yOffset, 0);
          group.add(label);
          return;
        }
        const oldMat = label.material;
        label.material = new THREE.SpriteMaterial({
          map: createTextTexture(text, { fontSize: 56, color: "#e6ebff" }),
          transparent: true,
          depthWrite: false,
        });
        oldMat.map?.dispose();
        oldMat.dispose();
      }

      function createNode(id, kind, props = {}) {
        let object;
        switch (kind) {
          case "group": {
            object = new THREE.Group();
            break;
          }
          case "text3d": {
            object = createTextSprite(props.text || "", {
              fontSize: props.size && props.size > 0.25 ? 92 : 64,
              scaleX: props.size && props.size > 0.25 ? 4.2 : 2.8,
              scaleY: props.size && props.size > 0.25 ? 1.0 : 0.66,
              color: props.color || "#f5f8ff",
            });
            break;
          }
          case "panel3d": {
            object = new THREE.Group();
            const w = props.w || 4.2;
            const h = props.h || 1.3;
            const panel = new THREE.Mesh(
              new THREE.PlaneGeometry(w, h),
              new THREE.MeshPhysicalMaterial({
                color: 0x0f1b3e,
                roughness: 0.35,
                metalness: 0.08,
                transparent: true,
                opacity: 0.86,
              })
            );
            panel.name = "panel";
            object.add(panel);
            ensureLabel(object, "panel-title", props.title || "Action", h * 0.2);
            ensureLabel(object, "panel-subtitle", props.subtitle || "", -h * 0.16);
            break;
          }
          case "trail": {
            object = new THREE.Group();
            const points = Array.isArray(props.points) ? props.points : [];
            const linePoints = points.map((p) => new THREE.Vector3(p.x || 0, p.y || 0, p.z || 0));
            if (linePoints.length >= 2) {
              const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
              const mat = new THREE.LineBasicMaterial({ color: 0x7ec2ff, transparent: true, opacity: 0.5 });
              const line = new THREE.Line(geo, mat);
              line.name = "trail-line";
              object.add(line);
            }
            break;
          }
          case "command_bar": {
            object = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.PlaneGeometry(props.w || 5.4, props.h || 0.65),
              new THREE.MeshStandardMaterial({ color: 0x132247, roughness: 0.5, metalness: 0.12, transparent: true, opacity: 0.84 })
            );
            base.name = "command-bg";
            object.add(base);
            ensureLabel(object, "command-label", props.label || "Type a command", 0);
            break;
          }
          case "orb":
          default: {
            object = new THREE.Group();
            const radius = props.radius || 0.28;
            const glow = new THREE.Mesh(
              new THREE.SphereGeometry(radius * 1.9, 24, 24),
              new THREE.MeshBasicMaterial({ color: colorForStatus(props.status), transparent: true, opacity: 0.12 })
            );
            glow.name = "orb-glow";
            object.add(glow);
            const mesh = new THREE.Mesh(
              new THREE.SphereGeometry(radius, 28, 28),
              new THREE.MeshStandardMaterial({
                color: colorForStatus(props.status),
                emissive: colorForStatus(props.status),
                emissiveIntensity: 0.34,
                roughness: 0.24,
                metalness: 0.22,
              })
            );
            mesh.name = "orb-core";
            object.add(mesh);
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(radius * 1.55, radius * 0.08, 14, 48),
              new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.36 })
            );
            ring.rotation.x = Math.PI * 0.5;
            ring.name = "orb-ring";
            object.add(ring);
            ensureLabel(object, "orb-label", props.label || id, radius * 2.5);
            animated.set(id, { type: "orb", ring });
            break;
          }
        }

        object.userData.adkId = id;
        object.userData.adkKind = kind;
        object.userData.props = { ...props };
        setTransform(object, props);
        return object;
      }

      function disposeObject(object) {
        object.traverse((child) => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            const material = child.material;
            if (Array.isArray(material)) {
              for (const m of material) {
                m.map?.dispose?.();
                m.dispose?.();
              }
            } else {
              material.map?.dispose?.();
              material.dispose?.();
            }
          }
        });
      }

      function attachToParent(node, parentId) {
        if (!parentId) {
          root.add(node);
          return;
        }
        const parent = registry.get(parentId)?.object;
        if (parent) {
          parent.add(node);
          return;
        }
        root.add(node);
      }

      function removeNode(id) {
        const entry = registry.get(id);
        if (!entry) {
          return;
        }
        const children = [];
        for (const [childId, childEntry] of registry.entries()) {
          if (childEntry.parentId === id) {
            children.push(childId);
          }
        }
        for (const childId of children) {
          removeNode(childId);
        }

        animated.delete(id);
        entry.object.parent?.remove(entry.object);
        disposeObject(entry.object);
        registry.delete(id);
      }

      function applyCreate(op) {
        if (!op?.id) {
          return;
        }
        if (registry.has(op.id)) {
          removeNode(op.id);
        }
        const object = createNode(op.id, op.kind || "group", op.props || {});
        attachToParent(object, op.parent || null);
        registry.set(op.id, {
          id: op.id,
          kind: op.kind || "group",
          parentId: op.parent || null,
          object,
          props: { ...(op.props || {}) },
        });
      }

      function updateTextSprite(sprite, text, color = "#f5f8ff") {
        const oldMat = sprite.material;
        sprite.material = new THREE.SpriteMaterial({
          map: createTextTexture(text || "", { fontSize: 62, color }),
          transparent: true,
          depthWrite: false,
        });
        oldMat.map?.dispose();
        oldMat.dispose();
      }

      function applyPatch(op) {
        const entry = registry.get(op?.id);
        if (!entry) {
          return;
        }
        entry.props = { ...entry.props, ...(op.props || {}) };
        const props = entry.props;
        setTransform(entry.object, props);

        if (entry.kind === "orb") {
          const color = colorForStatus(props.status);
          const core = entry.object.getObjectByName("orb-core");
          const glow = entry.object.getObjectByName("orb-glow");
          const ring = entry.object.getObjectByName("orb-ring");
          if (core?.material) {
            core.material.color.setHex(color);
            core.material.emissive.setHex(color);
          }
          if (glow?.material) {
            glow.material.color.setHex(color);
          }
          if (ring?.material) {
            ring.material.color.setHex(color);
          }
          if (props.selected === true) {
            entry.object.position.y = (props.y || 0) + 0.45;
            entry.object.scale.setScalar(1.28);
            if (core?.material) {
              core.material.emissiveIntensity = 0.75;
            }
          } else {
            if (typeof props.y === "number") {
              entry.object.position.y = props.y;
            }
            entry.object.scale.setScalar(1.0);
            if (core?.material) {
              core.material.emissiveIntensity = 0.34;
            }
          }
          ensureLabel(entry.object, "orb-label", props.label || entry.id, (props.radius || 0.28) * 2.5);
        }

        if (entry.kind === "text3d") {
          const sprite = entry.object;
          updateTextSprite(sprite, props.text || "", props.color || "#f5f8ff");
        }

        if (entry.kind === "panel3d") {
          ensureLabel(entry.object, "panel-title", props.title || "Action", (props.h || 1.3) * 0.2);
          ensureLabel(entry.object, "panel-subtitle", props.subtitle || "", -(props.h || 1.3) * 0.16);
        }

        if (entry.kind === "command_bar") {
          ensureLabel(entry.object, "command-label", props.label || "Type a command", 0);
        }
      }

      function applyRemove(op) {
        if (!op?.id) {
          return;
        }
        removeNode(op.id);
      }

      function applyOps(ops) {
        if (!Array.isArray(ops)) {
          return;
        }
        for (const op of ops) {
          if ((op.op === "create" || op.op === "patch") && op.id === "action-card" && op.props) {
            if (op.props.actionId) {
              setPendingAction(op.props.actionId, op.props.risk || "unknown");
            }
            if (typeof op.props.subtitle === "string") {
              const subtitle = op.props.subtitle.toLowerCase();
              if (subtitle.includes("approved") || subtitle.includes("rejected")) {
                setPendingAction(null, null);
              }
            }
          }
          if (op.op === "create") {
            applyCreate(op);
            opsApplied += 1;
          } else if (op.op === "patch") {
            applyPatch(op);
            opsApplied += 1;
          } else if (op.op === "remove") {
            applyRemove(op);
            opsApplied += 1;
          }
        }
        opsCountEl.textContent = `ops: ${opsApplied}`;
        objectsCountEl.textContent = `objects: ${registry.size}`;
      }

      function resize() {
        const w = viewport.clientWidth;
        const h = viewport.clientHeight;
        camera.aspect = w / Math.max(1, h);
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
      }
      new ResizeObserver(resize).observe(viewport);

      function onPointerDown(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObjects(root.children, true);
        if (!hits.length) {
          return;
        }
        let obj = hits[0].object;
        while (obj && !obj.userData?.adkId && obj.parent) {
          obj = obj.parent;
        }
        const id = obj?.userData?.adkId;
        if (id) {
          postEvent({ type: "select", id });
        }
      }
      renderer.domElement.addEventListener("pointerdown", onPointerDown);

      let frameCounter = 0;
      let fpsStart = performance.now();
      function animate(now) {
        requestAnimationFrame(animate);

        root.rotation.y = Math.sin(now * 0.00008) * 0.12;
        starField.rotation.y += 0.00008;

        for (const [id, meta] of animated.entries()) {
          const entry = registry.get(id);
          if (!entry) {
            animated.delete(id);
            continue;
          }
          if (meta.type === "orb") {
            const pulse = 1 + Math.sin(now * 0.003 + id.length) * 0.06;
            entry.object.scale.setScalar(pulse);
            if (meta.ring) {
              meta.ring.rotation.z += 0.01;
            }
          }
        }

        renderer.render(scene, camera);
        frameCounter += 1;
        if (frameCounter >= 20) {
          const elapsed = Math.max(1, performance.now() - fpsStart);
          const fps = Math.round((frameCounter * 1000) / elapsed);
          fpsEl.textContent = `fps: ${fps}`;
          frameCounter = 0;
          fpsStart = performance.now();
        }
      }

      async function createSession() {
        const res = await fetch("/api/3d/session", { method: "POST" });
        const data = await res.json();
        sessionId = data.session_id;
        sessionEl.value = `session: ${sessionId}`;
        log("session.created", data);
      }

      function parseOpsFromEnvelope(envelope) {
        const payload = envelope?.payload;
        if (!payload) {
          return null;
        }
        if (payload.kind === "ui_ops") {
          return payload.data?.ops || null;
        }
        if (Array.isArray(payload.ops)) {
          return payload.ops;
        }
        return null;
      }

      function connectSse() {
        if (eventSource) {
          eventSource.close();
        }
        statusEl.textContent = "streaming";
        eventSource = new EventSource(`/api/3d/stream/${sessionId}`);

        for (const eventName of ["ui_ops", "toast", "done", "error", "ping", "log"]) {
          eventSource.addEventListener(eventName, (evt) => {
            try {
              const data = JSON.parse(evt.data);
              if (eventName === "ui_ops") {
                const ops = parseOpsFromEnvelope(data);
                applyOps(ops);
              }
              if (eventName === "done") {
                statusEl.textContent = "done";
              }
              if (eventName === "error") {
                statusEl.textContent = "error";
              }
              log(`sse.${eventName}`, data);
            } catch {
              log(`sse.${eventName}`, evt.data);
            }
          });
        }

        eventSource.onerror = () => {
          statusEl.textContent = "disconnected";
          log("sse.error", { message: "connection dropped" });
        };
      }

      async function postEvent(event) {
        if (!sessionId) {
          return;
        }
        clientSeq += 1;
        const res = await fetch(`/api/3d/event/${sessionId}`, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ seq: clientSeq, event }),
        });
        const data = await res.json();
        log("event.ack", data);
      }

      async function runPrompt() {
        if (!sessionId) {
          return;
        }
        const prompt = promptEl.value.trim();
        if (!prompt) {
          return;
        }
        statusEl.textContent = "running";
        runBtn.disabled = true;
        try {
          const res = await fetch(`/api/3d/run/${sessionId}`, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ prompt }),
          });
          const data = await res.json();
          log("run.response", data);
        } finally {
          runBtn.disabled = false;
        }
      }

      async function boot() {
        resize();
        requestAnimationFrame(animate);
        await createSession();
        connectSse();
      }

      runBtn.addEventListener("click", runPrompt);
      commandBtn.addEventListener("click", () => postEvent({ type: "command", text: "show me incident blast radius" }));
      approveBtn.addEventListener("click", async () => {
        if (!pendingActionId) return;
        await postEvent({ type: "approve_action", action_id: pendingActionId, approved: true });
        setPendingAction(null, null);
      });
      rejectBtn.addEventListener("click", async () => {
        if (!pendingActionId) return;
        await postEvent({ type: "approve_action", action_id: pendingActionId, approved: false });
        setPendingAction(null, null);
      });

      boot().catch((err) => {
        statusEl.textContent = "error";
        log("boot.error", { message: String(err) });
      });
    </script>
  </body>
</html>
