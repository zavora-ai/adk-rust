Artifacts¶
Supported in ADKPython v0.1.0Go v0.1.0Java v0.1.0
In ADK, Artifacts represent a crucial mechanism for managing named, versioned binary data associated either with a specific user interaction session or persistently with a user across multiple sessions. They allow your agents and tools to handle data beyond simple text strings, enabling richer interactions involving files, images, audio, and other binary formats.

Note

The specific parameters or method names for the primitives may vary slightly by SDK language (e.g., save_artifact in Python, saveArtifact in Java). Refer to the language-specific API documentation for details.

What are Artifacts?¶
Definition: An Artifact is essentially a piece of binary data (like the content of a file) identified by a unique filename string within a specific scope (session or user). Each time you save an artifact with the same filename, a new version is created.

Representation: Artifacts are consistently represented using the standard google.genai.types.Part object. The core data is typically stored within an inline data structure of the Part (accessed via inline_data), which itself contains:

data: The raw binary content as bytes.
mime_type: A string indicating the type of the data (e.g., "image/png", "application/pdf"). This is essential for correctly interpreting the data later.

Python
Go
Java

import (
    "log"

    "google.golang.org/genai"
)

// Create a byte slice with the image data.
imageBytes, err := os.ReadFile("image.png")
if err != nil {
    log.Fatalf("Failed to read image file: %v", err)
}

// Create a new artifact with the image data.
imageArtifact := &genai.Part{
    InlineData: &genai.Blob{
        MIMEType: "image/png",
        Data:     imageBytes,
    },
}
log.Printf("Artifact MIME Type: %s", imageArtifact.InlineData.MIMEType)
log.Printf("Artifact Data (first 8 bytes): %x...", imageArtifact.InlineData.Data[:8])

Persistence & Management: Artifacts are not stored directly within the agent or session state. Their storage and retrieval are managed by a dedicated Artifact Service (an implementation of BaseArtifactService, defined in google.adk.artifacts. ADK provides various implementations, such as:
An in-memory service for testing or temporary storage (e.g., InMemoryArtifactService in Python, defined in google.adk.artifacts.in_memory_artifact_service.py).
A service for persistent storage using Google Cloud Storage (GCS) (e.g., GcsArtifactService in Python, defined in google.adk.artifacts.gcs_artifact_service.py). The chosen service implementation handles versioning automatically when you save data.
Why Use Artifacts?¶
While session state is suitable for storing small pieces of configuration or conversational context (like strings, numbers, booleans, or small dictionaries/lists), Artifacts are designed for scenarios involving binary or large data:

Handling Non-Textual Data: Easily store and retrieve images, audio clips, video snippets, PDFs, spreadsheets, or any other file format relevant to your agent's function.
Persisting Large Data: Session state is generally not optimized for storing large amounts of data. Artifacts provide a dedicated mechanism for persisting larger blobs without cluttering the session state.
User File Management: Provide capabilities for users to upload files (which can be saved as artifacts) and retrieve or download files generated by the agent (loaded from artifacts).
Sharing Outputs: Enable tools or agents to generate binary outputs (like a PDF report or a generated image) that can be saved via save_artifact and later accessed by other parts of the application or even in subsequent sessions (if using user namespacing).
Caching Binary Data: Store the results of computationally expensive operations that produce binary data (e.g., rendering a complex chart image) as artifacts to avoid regenerating them on subsequent requests.
In essence, whenever your agent needs to work with file-like binary data that needs to be persisted, versioned, or shared, Artifacts managed by an ArtifactService are the appropriate mechanism within ADK.

Common Use Cases¶
Artifacts provide a flexible way to handle binary data within your ADK applications.

Here are some typical scenarios where they prove valuable:

Generated Reports/Files:

A tool or agent generates a report (e.g., a PDF analysis, a CSV data export, an image chart).
Handling User Uploads:

A user uploads a file (e.g., an image for analysis, a document for summarization) through a front-end interface.
Storing Intermediate Binary Results:

An agent performs a complex multi-step process where one step generates intermediate binary data (e.g., audio synthesis, simulation results).
Persistent User Data:

Storing user-specific configuration or data that isn't a simple key-value state.
Caching Generated Binary Content:

An agent frequently generates the same binary output based on certain inputs (e.g., a company logo image, a standard audio greeting).
Core Concepts¶
Understanding artifacts involves grasping a few key components: the service that manages them, the data structure used to hold them, and how they are identified and versioned.

Artifact Service (BaseArtifactService)¶
Role: The central component responsible for the actual storage and retrieval logic for artifacts. It defines how and where artifacts are persisted.

Interface: Defined by the abstract base class BaseArtifactService. Any concrete implementation must provide methods for:

Save Artifact: Stores the artifact data and returns its assigned version number.
Load Artifact: Retrieves a specific version (or the latest) of an artifact.
List Artifact keys: Lists the unique filenames of artifacts within a given scope.
Delete Artifact: Removes an artifact (and potentially all its versions, depending on implementation).
List versions: Lists all available version numbers for a specific artifact filename.
Configuration: You provide an instance of an artifact service (e.g., InMemoryArtifactService, GcsArtifactService) when initializing the Runner. The Runner then makes this service available to agents and tools via the InvocationContext.


Python
Go
Java

import (
    "context"
    "log"

    "google.golang.org/adk/agent/llmagent"
    "google.golang.org/adk/artifactservice"
    "google.golang.org/adk/llm/gemini"
    "google.golang.org/adk/runner"
    "google.golang.org/adk/sessionservice"
    "google.golang.org/genai"
)

// Create a new context.
ctx := context.Background()
// Set the app name.
const appName = "my_artifact_app"
// Create a new Gemini model.
model, err := gemini.NewModel(ctx, "gemini-2.5-flash", &genai.ClientConfig{})
if err != nil {
    log.Fatalf("Failed to create model: %v", err)
}

// Create a new LLM agent.
myAgent, err := llmagent.New(llmagent.Config{
    Model:       model,
    Name:        "artifact_user_agent",
    Instruction: "You are an agent that describes images.",
    BeforeModelCallbacks: []llmagent.BeforeModelCallback{
        BeforeModelCallback,
    },
})
if err != nil {
    log.Fatalf("Failed to create agent: %v", err)
}

// Create a new in-memory artifact service.
artifactService := artifact.InMemoryService()
// Create a new in-memory session service.
sessionService := session.InMemoryService()

// Create a new runner.
r, err := runner.New(runner.Config{
    Agent:           myAgent,
    AppName:         appName,
    SessionService:  sessionService,
    ArtifactService: artifactService, // Provide the service instance here
})
if err != nil {
    log.Fatalf("Failed to create runner: %v", err)
}
log.Printf("Runner created successfully: %v", r)

Artifact Data¶
Standard Representation: Artifact content is universally represented using the google.genai.types.Part object, the same structure used for parts of LLM messages.

Key Attribute (inline_data): For artifacts, the most relevant attribute is inline_data, which is a google.genai.types.Blob object containing:

data (bytes): The raw binary content of the artifact.
mime_type (str): A standard MIME type string (e.g., 'application/pdf', 'image/png', 'audio/mpeg') describing the nature of the binary data. This is crucial for correct interpretation when loading the artifact.

Python
Go
Java

import (
    "log"
    "os"

    "google.golang.org/genai"
)

// Load imageBytes from a file
imageBytes, err := os.ReadFile("image.png")
if err != nil {
    log.Fatalf("Failed to read image file: %v", err)
}

// genai.NewPartFromBytes is a convenience function that is a shorthand for
// creating a &genai.Part with the InlineData field populated.
// Create a new artifact from the image data.
imageArtifact := genai.NewPartFromBytes([]byte(imageBytes), "image/png")

log.Printf("Artifact MIME Type: %s", imageArtifact.InlineData.MIMEType)

Filename¶
Identifier: A simple string used to name and retrieve an artifact within its specific namespace.
Uniqueness: Filenames must be unique within their scope (either the session or the user namespace).
Best Practice: Use descriptive names, potentially including file extensions (e.g., "monthly_report.pdf", "user_avatar.jpg"), although the extension itself doesn't dictate behavior – the mime_type does.
Versioning¶
Automatic Versioning: The artifact service automatically handles versioning. When you call save_artifact, the service determines the next available version number (typically starting from 0 and incrementing) for that specific filename and scope.
Returned by save_artifact: The save_artifact method returns the integer version number that was assigned to the newly saved artifact.
Retrieval:
load_artifact(..., version=None) (default): Retrieves the latest available version of the artifact.
load_artifact(..., version=N): Retrieves the specific version N.
Listing Versions: The list_versions method (on the service, not context) can be used to find all existing version numbers for an artifact.
Namespacing (Session vs. User)¶
Concept: Artifacts can be scoped either to a specific session or more broadly to a user across all their sessions within the application. This scoping is determined by the filename format and handled internally by the ArtifactService.

Default (Session Scope): If you use a plain filename like "report.pdf", the artifact is associated with the specific app_name, user_id, and session_id. It's only accessible within that exact session context.

User Scope ("user:" prefix): If you prefix the filename with "user:", like "user:profile.png", the artifact is associated only with the app_name and user_id. It can be accessed or updated from any session belonging to that user within the app.


Python
Go
Java

import (
    "log"
)

// Note: Namespacing is only supported when using the GCS ArtifactService implementation.
// A session-scoped artifact is only available within the current session.
sessionReportFilename := "summary.txt"
// A user-scoped artifact is available across all sessions for the current user.
userConfigFilename := "user:settings.json"

// When saving 'summary.txt' via ctx.Artifacts().Save,
// it's tied to the current app_name, user_id, and session_id.
// ctx.Artifacts().Save(sessionReportFilename, *artifact);

// When saving 'user:settings.json' via ctx.Artifacts().Save,
// the ArtifactService implementation should recognize the "user:" prefix
// and scope it to app_name and user_id, making it accessible across sessions for that user.
// ctx.Artifacts().Save(userConfigFilename, *artifact);

These core concepts work together to provide a flexible system for managing binary data within the ADK framework.

Interacting with Artifacts (via Context Objects)¶
The primary way you interact with artifacts within your agent's logic (specifically within callbacks or tools) is through methods provided by the CallbackContext and ToolContext objects. These methods abstract away the underlying storage details managed by the ArtifactService.

Prerequisite: Configuring the ArtifactService¶
Before you can use any artifact methods via the context objects, you must provide an instance of a BaseArtifactService implementation (like InMemoryArtifactService or GcsArtifactService) when initializing your Runner.


Python
Go
Java

import (
    "context"
    "log"

    "google.golang.org/adk/agent/llmagent"
    "google.golang.org/adk/artifactservice"
    "google.golang.org/adk/llm/gemini"
    "google.golang.org/adk/runner"
    "google.golang.org/adk/sessionservice"
    "google.golang.org/genai"
)

// Create a new context.
ctx := context.Background()
// Set the app name.
const appName = "my_artifact_app"
// Create a new Gemini model.
model, err := gemini.NewModel(ctx, "gemini-2.5-flash", &genai.ClientConfig{})
if err != nil {
    log.Fatalf("Failed to create model: %v", err)
}

// Create a new LLM agent.
myAgent, err := llmagent.New(llmagent.Config{
    Model:       model,
    Name:        "artifact_user_agent",
    Instruction: "You are an agent that describes images.",
    BeforeModelCallbacks: []llmagent.BeforeModelCallback{
        BeforeModelCallback,
    },
})
if err != nil {
    log.Fatalf("Failed to create agent: %v", err)
}

// Create a new in-memory artifact service.
artifactService := artifact.InMemoryService()
// Create a new in-memory session service.
sessionService := session.InMemoryService()

// Create a new runner.
r, err := runner.New(runner.Config{
    Agent:           myAgent,
    AppName:         appName,
    SessionService:  sessionService,
    ArtifactService: artifactService, // Provide the service instance here
})
if err != nil {
    log.Fatalf("Failed to create runner: %v", err)
}
log.Printf("Runner created successfully: %v", r)

Accessing Methods¶
The artifact interaction methods are available directly on instances of CallbackContext (passed to agent and model callbacks) and ToolContext (passed to tool callbacks). Remember that ToolContext inherits from CallbackContext.

Saving Artifacts¶
Code Example:


Python
Go
Java

import (
    "log"

    "google.golang.org/adk/agent"
    "google.golang.org/adk/llm"
    "google.golang.org/genai"
)

// saveReportCallback is a BeforeModel callback that saves a report from session state.
func saveReportCallback(ctx agent.CallbackContext, req *model.LLMRequest) (*model.LLMResponse, error) {
    // Get the report data from the session state.
    reportData, err := ctx.State().Get("report_bytes")
    if err != nil {
        log.Printf("No report data found in session state: %v", err)
        return nil, nil // No report to save, continue normally.
    }

    // Check if the report data is in the expected format.
    reportBytes, ok := reportData.([]byte)
    if !ok {
        log.Printf("Report data in session state was not in the expected byte format.")
        return nil, nil
    }

    // Create a new artifact with the report data.
    reportArtifact := &genai.Part{
        InlineData: &genai.Blob{
            MIMEType: "application/pdf",
            Data:     reportBytes,
        },
    }
    // Set the filename for the artifact.
    filename := "generated_report.pdf"
    // Save the artifact to the artifact service.
    _, err = ctx.Artifacts().Save(ctx, filename, reportArtifact)
    if err != nil {
        log.Printf("An unexpected error occurred during Go artifact save: %v", err)
        // Depending on requirements, you might want to return an error to the user.
        return nil, nil
    }
    log.Printf("Successfully saved Go artifact '%s'.", filename)
    // Return nil to continue to the next callback or the model.
    return nil, nil
}

Loading Artifacts¶
Code Example:


Python
Go
Java

import (
    "log"

    "google.golang.org/adk/agent"
    "google.golang.org/adk/llm"
)

// loadArtifactsCallback is a BeforeModel callback that loads a specific artifact
// and adds its content to the LLM request.
func loadArtifactsCallback(ctx agent.CallbackContext, req *model.LLMRequest) (*model.LLMResponse, error) {
    log.Println("[Callback] loadArtifactsCallback triggered.")
    // In a real app, you would parse the user's request to find a filename.
    // For this example, we'll hardcode a filename to demonstrate.
    const filenameToLoad = "generated_report.pdf"

    // Load the artifact from the artifact service.
    loadedPartResponse, err := ctx.Artifacts().Load(ctx, filenameToLoad)
    if err != nil {
        log.Printf("Callback could not load artifact '%s': %v", filenameToLoad, err)
        return nil, nil // File not found or error, continue to model.
    }

    loadedPart := loadedPartResponse.Part

    log.Printf("Callback successfully loaded artifact '%s'.", filenameToLoad)

    // Ensure there's at least one content in the request to append to.
    if len(req.Contents) == 0 {
        req.Contents = []*genai.Content{{Parts: []*genai.Part{
            genai.NewPartFromText("SYSTEM: The following file is provided for context:\n"),
        }}}
    }

    // Add the loaded artifact to the request for the model.
    lastContent := req.Contents[len(req.Contents)-1]
    lastContent.Parts = append(lastContent.Parts, loadedPart)
    log.Printf("Added artifact '%s' to LLM request.", filenameToLoad)

    // Return nil to continue to the next callback or the model.
    return nil, nil // Continue to next callback or LLM call
}

Listing Artifact Filenames¶
Code Example:


Python
Go
Java

import (
    "fmt"
    "log"
    "strings"

    "google.golang.org/adk/agent"
    "google.golang.org/adk/llm"
    "google.golang.org/genai"
)

// listUserFilesCallback is a BeforeModel callback that lists available artifacts
// and adds the list as context to the LLM request.
func listUserFilesCallback(ctx agent.CallbackContext, req *model.LLMRequest) (*model.LLMResponse, error) {
    log.Println("[Callback] listUserFilesCallback triggered.")
    // List the available artifacts from the artifact service.
    listResponse, err := ctx.Artifacts().List(ctx)
    if err != nil {
        log.Printf("An unexpected error occurred during Go artifact list: %v", err)
        return nil, nil // Continue, but log the error.
    }

    availableFiles := listResponse.FileNames

    log.Printf("Found %d available files.", len(availableFiles))

    // If there are available files, add them to the LLM request.
    if len(availableFiles) > 0 {
        var fileListStr strings.Builder
        fileListStr.WriteString("SYSTEM: The following files are available:\n")
        for _, fname := range availableFiles {
            fileListStr.WriteString(fmt.Sprintf("- %s\n", fname))
        }
        // Prepend this information to the user's request for the model.
        if len(req.Contents) > 0 {
            lastContent := req.Contents[len(req.Contents)-1]
            if len(lastContent.Parts) > 0 {
                fileListStr.WriteString("\n") // Add a newline for separation.
                lastContent.Parts[0] = genai.NewPartFromText(fileListStr.String() + lastContent.Parts[0].Text)
                log.Println("Added file list to LLM request context.")
            }
        }
        log.Printf("Available files:\n%s", fileListStr.String())
    } else {
        log.Println("No available files found to list.")
    }

    // Return nil to continue to the next callback or the model.
    return nil, nil // Continue to next callback or LLM call
}

These methods for saving, loading, and listing provide a convenient and consistent way to manage binary data persistence within ADK, whether using Python's context objects or directly interacting with the BaseArtifactService in Java, regardless of the chosen backend storage implementation.

Available Implementations¶
ADK provides concrete implementations of the BaseArtifactService interface, offering different storage backends suitable for various development stages and deployment needs. These implementations handle the details of storing, versioning, and retrieving artifact data based on the app_name, user_id, session_id, and filename (including the user: namespace prefix).

InMemoryArtifactService¶
Storage Mechanism:
Python: Uses a Python dictionary (self.artifacts) held in the application's memory. The dictionary keys represent the artifact path, and the values are lists of types.Part, where each list element is a version.
Java: Uses nested HashMap instances (private final Map<String, Map<String, Map<String, Map<String, List<Part>>>>> artifacts;) held in memory. The keys at each level are appName, userId, sessionId, and filename respectively. The innermost List<Part> stores the versions of the artifact, where the list index corresponds to the version number.
Key Features:
Simplicity: Requires no external setup or dependencies beyond the core ADK library.
Speed: Operations are typically very fast as they involve in-memory map/dictionary lookups and list manipulations.
Ephemeral: All stored artifacts are lost when the application process terminates. Data does not persist between application restarts.
Use Cases:
Ideal for local development and testing where persistence is not required.
Suitable for short-lived demonstrations or scenarios where artifact data is purely temporary within a single run of the application.
Instantiation:


Python
Go
Java

import (
    "google.golang.org/adk/artifactservice"
)

// Simply instantiate the service
artifactService := artifact.InMemoryService()
log.Printf("InMemoryArtifactService (Go) instantiated: %T", artifactService)

// Use the service in your runner
// r, _ := runner.New(runner.Config{
//  Agent:           agent,
//  AppName:         "my_app",
//  SessionService:  sessionService,
//  ArtifactService: artifactService,
// })

GcsArtifactService¶
Storage Mechanism: Leverages Google Cloud Storage (GCS) for persistent artifact storage. Each version of an artifact is stored as a separate object (blob) within a specified GCS bucket.
Object Naming Convention: It constructs GCS object names (blob names) using a hierarchical path structure.
Key Features:
Persistence: Artifacts stored in GCS persist across application restarts and deployments.
Scalability: Leverages the scalability and durability of Google Cloud Storage.
Versioning: Explicitly stores each version as a distinct GCS object. The saveArtifact method in GcsArtifactService.
Permissions Required: The application environment needs appropriate credentials (e.g., Application Default Credentials) and IAM permissions to read from and write to the specified GCS bucket.
Use Cases:
Production environments requiring persistent artifact storage.
Scenarios where artifacts need to be shared across different application instances or services (by accessing the same GCS bucket).
Applications needing long-term storage and retrieval of user or session data.
Instantiation:


Python
Java

from google.adk.artifacts import GcsArtifactService

# Specify the GCS bucket name
gcs_bucket_name_py = "your-gcs-bucket-for-adk-artifacts" # Replace with your bucket name

try:
    gcs_service_py = GcsArtifactService(bucket_name=gcs_bucket_name_py)
    print(f"Python GcsArtifactService initialized for bucket: {gcs_bucket_name_py}")
    # Ensure your environment has credentials to access this bucket.
    # e.g., via Application Default Credentials (ADC)

    # Then pass it to the Runner
    # runner = Runner(..., artifact_service=gcs_service_py)

except Exception as e:
    # Catch potential errors during GCS client initialization (e.g., auth issues)
    print(f"Error initializing Python GcsArtifactService: {e}")
    # Handle the error appropriately - maybe fall back to InMemory or raise

Choosing the appropriate ArtifactService implementation depends on your application's requirements for data persistence, scalability, and operational environment.

Best Practices¶
To use artifacts effectively and maintainably:

Choose the Right Service: Use InMemoryArtifactService for rapid prototyping, testing, and scenarios where persistence isn't needed. Use GcsArtifactService (or implement your own BaseArtifactService for other backends) for production environments requiring data persistence and scalability.
Meaningful Filenames: Use clear, descriptive filenames. Including relevant extensions (.pdf, .png, .wav) helps humans understand the content, even though the mime_type dictates programmatic handling. Establish conventions for temporary vs. persistent artifact names.
Specify Correct MIME Types: Always provide an accurate mime_type when creating the types.Part for save_artifact. This is critical for applications or tools that later load_artifact to interpret the bytes data correctly. Use standard IANA MIME types where possible.
Understand Versioning: Remember that load_artifact() without a specific version argument retrieves the latest version. If your logic depends on a specific historical version of an artifact, be sure to provide the integer version number when loading.
Use Namespacing (user:) Deliberately: Only use the "user:" prefix for filenames when the data truly belongs to the user and should be accessible across all their sessions. For data specific to a single conversation or session, use regular filenames without the prefix.
Error Handling:
Always check if an artifact_service is actually configured before calling context methods (save_artifact, load_artifact, list_artifacts) – they will raise a ValueError if the service is None.
Check the return value of load_artifact, as it will be None if the artifact or version doesn't exist. Don't assume it always returns a Part.
Be prepared to handle exceptions from the underlying storage service, especially with GcsArtifactService (e.g., google.api_core.exceptions.Forbidden for permission issues, NotFound if the bucket doesn't exist, network errors).
Size Considerations: Artifacts are suitable for typical file sizes, but be mindful of potential costs and performance impacts with extremely large files, especially with cloud storage. InMemoryArtifactService can consume significant memory if storing many large artifacts. Evaluate if very large data might be better handled through direct GCS links or other specialized storage solutions rather than passing entire byte arrays in-memory.
Cleanup Strategy: For persistent storage like GcsArtifactService, artifacts remain until explicitly deleted. If artifacts represent temporary data or have a limited lifespan, implement a strategy for cleanup. This might involve:
Using GCS lifecycle policies on the bucket.
Building specific tools or administrative functions that utilize the artifact_service.delete_artifact method (note: delete is not exposed via context objects for safety).
Carefully managing filenames to allow pattern-based deletion if needed.